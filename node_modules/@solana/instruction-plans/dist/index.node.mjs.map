{"version":3,"sources":["../src/instruction-plan.ts","../src/transaction-plan-result.ts","../src/transaction-plan-executor.ts","../src/transaction-plan.ts","../src/transaction-planner.ts"],"names":["context","SolanaError","traverse","traverseSequential","traverseParallel","traverseSingle","candidate","message","getAbortablePromise","getTransactionMessageSize","TRANSACTION_SIZE_LIMIT","SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN","SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND"],"mappings":"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","file":"index.node.mjs","sourcesContent":["import {\n    SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN,\n    SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE,\n    SolanaError,\n} from '@solana/errors';\nimport { Instruction } from '@solana/instructions';\nimport {\n    appendTransactionMessageInstruction,\n    BaseTransactionMessage,\n    TransactionMessageWithFeePayer,\n} from '@solana/transaction-messages';\nimport { getTransactionMessageSize, TRANSACTION_SIZE_LIMIT } from '@solana/transactions';\n\n/**\n * A set of instructions with constraints on how they can be executed.\n *\n * This is structured as a recursive tree of plans in order to allow for\n * parallel execution, sequential execution and combinations of both.\n *\n * Namely the following plans are supported:\n * - {@link SingleInstructionPlan} - A plan that contains a single instruction.\n *   This is a simple instruction wrapper and the simplest leaf in this tree.\n * - {@link ParallelInstructionPlan} - A plan that contains other plans that\n *   can be executed in parallel.\n * - {@link SequentialInstructionPlan} - A plan that contains other plans that\n *   must be executed sequentially. It also defines whether the plan is divisible\n *   meaning that instructions inside it can be split into separate transactions.\n * - {@link MessagePackerInstructionPlan} - A plan that can dynamically pack\n *  instructions into transaction messages.\n *\n * Helpers are provided for each of these plans to make it easier to create them.\n *\n * @example\n * ```ts\n * const myInstructionPlan: InstructionPlan = parallelInstructionPlan([\n *    sequentialInstructionPlan([instructionA, instructionB]),\n *    instructionC,\n *    instructionD,\n * ]);\n * ```\n *\n * @see {@link SingleInstructionPlan}\n * @see {@link ParallelInstructionPlan}\n * @see {@link SequentialInstructionPlan}\n * @see {@link MessagePackerInstructionPlan}\n */\nexport type InstructionPlan =\n    | MessagePackerInstructionPlan\n    | ParallelInstructionPlan\n    | SequentialInstructionPlan\n    | SingleInstructionPlan;\n\n/**\n * A plan wrapping other plans that must be executed sequentially.\n *\n * It also defines whether nested plans are divisible — meaning that\n * the instructions inside them can be split into separate transactions.\n * When `divisible` is `false`, the instructions inside the plan should\n * all be executed atomicly — either in a single transaction or in a\n * transaction bundle.\n *\n * You may use the {@link sequentialInstructionPlan} and {@link nonDivisibleSequentialInstructionPlan}\n * helpers to create objects of this type.\n *\n * @example Simple sequential plan with two instructions.\n * ```ts\n * const plan = sequentialInstructionPlan([instructionA, instructionB]);\n * plan satisfies SequentialInstructionPlan;\n * ```\n *\n * @example Non-divisible sequential plan with two instructions.\n * ```ts\n * const plan = nonDivisibleSequentialInstructionPlan([instructionA, instructionB]);\n * plan satisfies SequentialInstructionPlan & { divisible: false };\n * ```\n *\n * @example Sequential plan with nested parallel plans.\n * Here, instructions A and B can be executed in parallel, but they must both be finalized\n * before instructions C and D can be sent — which can also be executed in parallel.\n * ```ts\n * const plan = sequentialInstructionPlan([\n *   parallelInstructionPlan([instructionA, instructionB]),\n *   parallelInstructionPlan([instructionC, instructionD]),\n * ]);\n * plan satisfies SequentialInstructionPlan & { divisible: false };\n * ```\n *\n * @see {@link sequentialInstructionPlan}\n * @see {@link nonDivisibleSequentialInstructionPlan}\n */\nexport type SequentialInstructionPlan = Readonly<{\n    divisible: boolean;\n    kind: 'sequential';\n    plans: InstructionPlan[];\n}>;\n\n/**\n * A plan wrapping other plans that can be executed in parallel.\n *\n * This means direct children of this plan can be executed in separate\n * parallel transactions without consequence.\n * However, the children themselves can define additional constraints\n * for that specific branch of the tree — such as the {@link SequentialInstructionPlan}.\n *\n * You may use the {@link parallelInstructionPlan} helper to create objects of this type.\n *\n * @example Simple parallel plan with two instructions.\n * ```ts\n * const plan = parallelInstructionPlan([instructionA, instructionB]);\n * plan satisfies ParallelInstructionPlan;\n * ```\n *\n * @example Parallel plan with nested sequential plans.\n * Here, instructions A and B must be executed sequentially and so must instructions C and D,\n * but both pairs can be executed in parallel.\n * ```ts\n * const plan = parallelInstructionPlan([\n *   sequentialInstructionPlan([instructionA, instructionB]),\n *   sequentialInstructionPlan([instructionC, instructionD]),\n * ]);\n * plan satisfies ParallelInstructionPlan;\n * ```\n *\n * @see {@link parallelInstructionPlan}\n */\nexport type ParallelInstructionPlan = Readonly<{\n    kind: 'parallel';\n    plans: InstructionPlan[];\n}>;\n\n/**\n * A plan that contains a single instruction.\n *\n * This is a simple instruction wrapper that transforms an instruction into a plan.\n *\n * You may use the {@link singleInstructionPlan} helper to create objects of this type.\n *\n * @example\n * ```ts\n * const plan = singleInstructionPlan(instructionA);\n * plan satisfies SingleInstructionPlan;\n * ```\n *\n * @see {@link singleInstructionPlan}\n */\nexport type SingleInstructionPlan<TInstruction extends Instruction = Instruction> = Readonly<{\n    instruction: TInstruction;\n    kind: 'single';\n}>;\n\n/**\n * A plan that can dynamically pack instructions into transaction messages.\n *\n * This plan provides a {@link MessagePacker} via the `getMessagePacker`\n * method, which enables instructions to be dynamically packed into the\n * provided transaction message until there are no more instructions to pack.\n * The returned {@link MessagePacker} offers a `packMessageToCapacity(message)`\n * method that packs the provided message — when possible — and a `done()` method\n * that checks whether there are more instructions to pack.\n *\n * Several helper functions are provided to create objects of this type such as\n * {@link getLinearMessagePackerInstructionPlan} or {@link getMessagePackerInstructionPlanFromInstructions}.\n *\n * @example An message packer plan for a write instruction that uses as many bytes as possible.\n * ```ts\n * const plan = getLinearMessagePackerInstructionPlan({\n *   totalLength: dataToWrite.length,\n *   getInstruction: (offset, length) =>\n *     getWriteInstruction({\n *       offset,\n *       data: dataToWrite.slice(offset, offset + length),\n *     }),\n * });\n * plan satisfies MessagePackerInstructionPlan;\n * ```\n *\n * @example A message packer plan for multiple realloc instructions.\n * ```ts\n * const plan = getReallocMessagePackerInstructionPlan({\n *   totalSize: additionalDataSize,\n *   getInstruction: (size) => getExtendInstruction({ length: size }),\n * });\n * plan satisfies MessagePackerInstructionPlan;\n * ```\n *\n * @example Using a message packer plan.\n * ```ts\n * let plan: MessagePackerInstructionPlan;\n * const messagePacker = plan.getMessagePacker();\n *\n * while (!messagePacker.done()) {\n *   try {\n *     transactionMessage = messagePacker.packMessageToCapacity(transactionMessage);\n *   } catch (error) {\n *     // The current transaction message cannot be used to pack this plan.\n *     // We should create a new one and try again.\n *   }\n * }\n * ```\n *\n * @see {@link getLinearMessagePackerInstructionPlan}\n * @see {@link getMessagePackerInstructionPlanFromInstructions}\n * @see {@link getReallocMessagePackerInstructionPlan}\n */\nexport type MessagePackerInstructionPlan = Readonly<{\n    getMessagePacker: () => MessagePacker;\n    kind: 'messagePacker';\n}>;\n\n/**\n * The message packer returned by the {@link MessagePackerInstructionPlan}.\n *\n * It offers a `packMessageToCapacity(transactionMessage)` method that packs as many instructions\n * as possible into the provided transaction message, while still being able to fit into the\n * transaction size limit. It returns the updated transaction message with the packed instructions\n * or throws an error if the current transaction message cannot accommodate this plan.\n *\n * The `done()` method checks whether there are more instructions to pack into\n * transaction messages.\n *\n * @example\n * ```ts\n * let plan: MessagePackerInstructionPlan;\n * const messagePacker = plan.getMessagePacker();\n *\n * while (!messagePacker.done()) {\n *   try {\n *     transactionMessage = messagePacker.packMessageToCapacity(transactionMessage);\n *   } catch (error) {\n *     // The current transaction message cannot be used to pack this plan.\n *     // We should create a new one and try again.\n *   }\n * }\n * ```\n *\n * @see {@link MessagePackerInstructionPlan}\n */\nexport type MessagePacker = Readonly<{\n    /** Checks whether the message packer has more instructions to pack into transaction messages. */\n    done: () => boolean;\n    /**\n     * Packs the provided transaction message with instructions or throws if not possible.\n     *\n     * @throws {@link SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN}\n     *   if the provided transaction message cannot be used to fill the next instructions.\n     * @throws {@link SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE}\n     *   if the message packer is already done and no more instructions can be packed.\n     */\n    packMessageToCapacity: (\n        transactionMessage: BaseTransactionMessage & TransactionMessageWithFeePayer,\n    ) => BaseTransactionMessage & TransactionMessageWithFeePayer;\n}>;\n\n/**\n * Creates a {@link ParallelInstructionPlan} from an array of nested plans.\n *\n * It can accept {@link Instruction} objects directly, which will be wrapped\n * in {@link SingleInstructionPlan | SingleInstructionPlans} automatically.\n *\n * @example Using explicit {@link SingleInstructionPlan | SingleInstructionPlans}.\n * ```ts\n * const plan = parallelInstructionPlan([\n *   singleInstructionPlan(instructionA),\n *   singleInstructionPlan(instructionB),\n * ]);\n * ```\n *\n * @example Using {@link Instruction | Instructions} directly.\n * ```ts\n * const plan = parallelInstructionPlan([instructionA, instructionB]);\n * ```\n *\n * @see {@link ParallelInstructionPlan}\n */\nexport function parallelInstructionPlan(plans: (Instruction | InstructionPlan)[]): ParallelInstructionPlan {\n    return Object.freeze({\n        kind: 'parallel',\n        plans: parseSingleInstructionPlans(plans),\n    });\n}\n\n/**\n * Creates a divisible {@link SequentialInstructionPlan} from an array of nested plans.\n *\n * It can accept {@link Instruction} objects directly, which will be wrapped\n * in {@link SingleInstructionPlan | SingleInstructionPlans} automatically.\n *\n * @example Using explicit {@link SingleInstructionPlan | SingleInstructionPlans}.\n * ```ts\n * const plan = sequentialInstructionPlan([\n *   singleInstructionPlan(instructionA),\n *   singleInstructionPlan(instructionB),\n * ]);\n * ```\n *\n * @example Using {@link Instruction | Instructions} directly.\n * ```ts\n * const plan = sequentialInstructionPlan([instructionA, instructionB]);\n * ```\n *\n * @see {@link SequentialInstructionPlan}\n */\nexport function sequentialInstructionPlan(\n    plans: (Instruction | InstructionPlan)[],\n): SequentialInstructionPlan & { divisible: true } {\n    return Object.freeze({\n        divisible: true,\n        kind: 'sequential',\n        plans: parseSingleInstructionPlans(plans),\n    });\n}\n\n/**\n * Creates a non-divisible {@link SequentialInstructionPlan} from an array of nested plans.\n *\n * It can accept {@link Instruction} objects directly, which will be wrapped\n * in {@link SingleInstructionPlan | SingleInstructionPlans} automatically.\n *\n * @example Using explicit {@link SingleInstructionPlan | SingleInstructionPlans}.\n * ```ts\n * const plan = nonDivisibleSequentialInstructionPlan([\n *   singleInstructionPlan(instructionA),\n *   singleInstructionPlan(instructionB),\n * ]);\n * ```\n *\n * @example Using {@link Instruction | Instructions} directly.\n * ```ts\n * const plan = nonDivisibleSequentialInstructionPlan([instructionA, instructionB]);\n * ```\n *\n * @see {@link SequentialInstructionPlan}\n */\nexport function nonDivisibleSequentialInstructionPlan(\n    plans: (Instruction | InstructionPlan)[],\n): SequentialInstructionPlan & { divisible: false } {\n    return Object.freeze({\n        divisible: false,\n        kind: 'sequential',\n        plans: parseSingleInstructionPlans(plans),\n    });\n}\n\n/**\n * Creates a {@link SingleInstructionPlan} from an {@link Instruction} object.\n *\n * @example\n * ```ts\n * const plan = singleInstructionPlan(instructionA);\n * ```\n *\n * @see {@link SingleInstructionPlan}\n */\nexport function singleInstructionPlan(instruction: Instruction): SingleInstructionPlan {\n    return Object.freeze({ instruction, kind: 'single' });\n}\n\nfunction parseSingleInstructionPlans(plans: (Instruction | InstructionPlan)[]): InstructionPlan[] {\n    return plans.map(plan => ('kind' in plan ? plan : singleInstructionPlan(plan)));\n}\n\n/**\n * Creates a {@link MessagePackerInstructionPlan} that packs instructions\n * such that each instruction consumes as many bytes as possible from the given\n * `totalLength` while still being able to fit into the given transaction messages.\n *\n * This is particularly useful for instructions that write data to accounts and must\n * span multiple transactions due to their size limit.\n *\n * This message packer will first call `getInstruction` with a length of zero to\n * determine the base size of the instruction before figuring out how many\n * additional bytes can be packed into the transaction message. That remaining space\n * will then be used to call `getInstruction` again with the appropriate length.\n *\n * @param getInstruction - A function that returns an instruction for a given offset and length.\n * @param totalLength - The total length of the data to write, in bytes.\n *\n * @example\n * ```ts\n * const plan = getLinearMessagePackerInstructionPlan({\n *   totalLength: dataToWrite.length,\n *   getInstruction: (offset, length) =>\n *     getWriteInstruction({\n *       offset,\n *       data: dataToWrite.slice(offset, offset + length),\n *     }),\n * });\n * plan satisfies MessagePackerInstructionPlan;\n * ```\n *\n * @see {@link MessagePackerInstructionPlan}\n */\nexport function getLinearMessagePackerInstructionPlan({\n    getInstruction,\n    totalLength: totalBytes,\n}: {\n    getInstruction: (offset: number, length: number) => Instruction;\n    totalLength: number;\n}): MessagePackerInstructionPlan {\n    return Object.freeze({\n        getMessagePacker: () => {\n            let offset = 0;\n            return Object.freeze({\n                done: () => offset >= totalBytes,\n                packMessageToCapacity: (message: BaseTransactionMessage & TransactionMessageWithFeePayer) => {\n                    if (offset >= totalBytes) {\n                        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE);\n                    }\n\n                    const messageSizeWithBaseInstruction = getTransactionMessageSize(\n                        appendTransactionMessageInstruction(getInstruction(offset, 0), message),\n                    );\n                    const freeSpace =\n                        TRANSACTION_SIZE_LIMIT -\n                        messageSizeWithBaseInstruction /* Includes the base instruction (length: 0). */ -\n                        1; /* Leeway for shortU16 numbers in transaction headers. */\n\n                    if (freeSpace <= 0) {\n                        const messageSize = getTransactionMessageSize(message);\n                        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN, {\n                            // (+1) We need to pack at least one byte of data otherwise\n                            // there is no point packing the base instruction alone.\n                            numBytesRequired: messageSizeWithBaseInstruction - messageSize + 1,\n                            // (-1) Leeway for shortU16 numbers in transaction headers.\n                            numFreeBytes: TRANSACTION_SIZE_LIMIT - messageSize - 1,\n                        });\n                    }\n\n                    const length = Math.min(totalBytes - offset, freeSpace);\n                    const instruction = getInstruction(offset, length);\n                    offset += length;\n                    return appendTransactionMessageInstruction(instruction, message);\n                },\n            });\n        },\n        kind: 'messagePacker',\n    });\n}\n\n/**\n * Creates a {@link MessagePackerInstructionPlan} from a list of instructions.\n *\n * This can be useful to prepare a set of instructions that can be iterated over\n * — e.g. to pack a list of instructions that gradually reallocate the size of an account\n * one `REALLOC_LIMIT` (10'240 bytes) at a time.\n *\n * @example\n * ```ts\n * const plan = getMessagePackerInstructionPlanFromInstructions([\n *   instructionA,\n *   instructionB,\n *   instructionC,\n * ]);\n *\n * const messagePacker = plan.getMessagePacker();\n * firstTransactionMessage = messagePacker.packMessageToCapacity(firstTransactionMessage);\n * // Contains instruction A and instruction B.\n * secondTransactionMessage = messagePacker.packMessageToCapacity(secondTransactionMessage);\n * // Contains instruction C.\n * messagePacker.done(); // true\n * ```\n *\n * @see {@link MessagePackerInstructionPlan}\n * @see {@link getReallocMessagePackerInstructionPlan}\n */\nexport function getMessagePackerInstructionPlanFromInstructions<TInstruction extends Instruction = Instruction>(\n    instructions: TInstruction[],\n): MessagePackerInstructionPlan {\n    return Object.freeze({\n        getMessagePacker: () => {\n            let instructionIndex = 0;\n            return Object.freeze({\n                done: () => instructionIndex >= instructions.length,\n                packMessageToCapacity: (message: BaseTransactionMessage & TransactionMessageWithFeePayer) => {\n                    if (instructionIndex >= instructions.length) {\n                        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE);\n                    }\n\n                    const originalMessageSize = getTransactionMessageSize(message);\n\n                    for (let index = instructionIndex; index < instructions.length; index++) {\n                        message = appendTransactionMessageInstruction(instructions[index], message);\n                        const messageSize = getTransactionMessageSize(message);\n\n                        if (messageSize > TRANSACTION_SIZE_LIMIT) {\n                            if (index === instructionIndex) {\n                                throw new SolanaError(\n                                    SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN,\n                                    {\n                                        numBytesRequired: messageSize - originalMessageSize,\n                                        numFreeBytes: TRANSACTION_SIZE_LIMIT - originalMessageSize,\n                                    },\n                                );\n                            }\n                            instructionIndex = index;\n                            return message;\n                        }\n                    }\n\n                    instructionIndex = instructions.length;\n                    return message;\n                },\n            });\n        },\n        kind: 'messagePacker',\n    });\n}\n\nconst REALLOC_LIMIT = 10_240;\n\n/**\n * Creates a {@link MessagePackerInstructionPlan} that packs a list of realloc instructions.\n *\n * That is, it splits instruction by chunks of `REALLOC_LIMIT` (10'240) bytes until\n * the given total size is reached.\n *\n * @example\n * ```ts\n * const plan = getReallocMessagePackerInstructionPlan({\n *   totalSize: additionalDataSize,\n *   getInstruction: (size) => getExtendInstruction({ length: size }),\n * });\n * ```\n *\n * @see {@link MessagePackerInstructionPlan}\n */\nexport function getReallocMessagePackerInstructionPlan({\n    getInstruction,\n    totalSize,\n}: {\n    getInstruction: (size: number) => Instruction;\n    totalSize: number;\n}): MessagePackerInstructionPlan {\n    const numberOfInstructions = Math.ceil(totalSize / REALLOC_LIMIT);\n    const lastInstructionSize = totalSize % REALLOC_LIMIT;\n    const instructions = new Array(numberOfInstructions)\n        .fill(0)\n        .map((_, i) => getInstruction(i === numberOfInstructions - 1 ? lastInstructionSize : REALLOC_LIMIT));\n\n    return getMessagePackerInstructionPlanFromInstructions(instructions);\n}\n","import { SolanaError } from '@solana/errors';\nimport { BaseTransactionMessage, TransactionMessageWithFeePayer } from '@solana/transaction-messages';\nimport { Transaction } from '@solana/transactions';\n\n/**\n * The result of executing a transaction plan.\n *\n * This is structured as a recursive tree of results that mirrors the structure\n * of the original transaction plan, capturing the execution status at each level.\n *\n * Namely, the following result types are supported:\n * - {@link SingleTransactionPlanResult} - A result for a single transaction message\n *   containing its execution status.\n * - {@link ParallelTransactionPlanResult} - A result containing other results that\n *   were executed in parallel.\n * - {@link SequentialTransactionPlanResult} - A result containing other results that\n *   were executed sequentially. It also retains the divisibility property from the\n *   original plan.\n *\n * @template TContext - The type of the context object that may be passed along with successful results\n *\n * @see {@link SingleTransactionPlanResult}\n * @see {@link ParallelTransactionPlanResult}\n * @see {@link SequentialTransactionPlanResult}\n * @see {@link TransactionPlanResultStatus}\n */\nexport type TransactionPlanResult<TContext extends TransactionPlanResultContext = TransactionPlanResultContext> =\n    | ParallelTransactionPlanResult<TContext>\n    | SequentialTransactionPlanResult<TContext>\n    | SingleTransactionPlanResult<TContext>;\n\n/** A context object that may be passed along with successful results. */\nexport type TransactionPlanResultContext = Record<number | string | symbol, unknown>;\n\n/**\n * A result for a sequential transaction plan.\n *\n * This represents the execution result of a {@link SequentialTransactionPlan} and\n * contains child results that were executed sequentially. It also retains the\n * divisibility property from the original plan.\n *\n * You may use the {@link sequentialTransactionPlanResult} and\n * {@link nonDivisibleSequentialTransactionPlanResult} helpers to create objects of this type.\n *\n * @template TContext - The type of the context object that may be passed along with successful results\n *\n * @example\n * ```ts\n * const result = sequentialTransactionPlanResult([\n *   singleResultA,\n *   singleResultB,\n * ]);\n * result satisfies SequentialTransactionPlanResult;\n * ```\n *\n * @example\n * Non-divisible sequential result.\n * ```ts\n * const result = nonDivisibleSequentialTransactionPlanResult([\n *   singleResultA,\n *   singleResultB,\n * ]);\n * result satisfies SequentialTransactionPlanResult & { divisible: false };\n * ```\n *\n * @see {@link sequentialTransactionPlanResult}\n * @see {@link nonDivisibleSequentialTransactionPlanResult}\n */\nexport type SequentialTransactionPlanResult<\n    TContext extends TransactionPlanResultContext = TransactionPlanResultContext,\n> = Readonly<{\n    divisible: boolean;\n    kind: 'sequential';\n    plans: TransactionPlanResult<TContext>[];\n}>;\n\n/**\n * A result for a parallel transaction plan.\n *\n * This represents the execution result of a {@link ParallelTransactionPlan} and\n * contains child results that were executed in parallel.\n *\n * You may use the {@link parallelTransactionPlanResult} helper to create objects of this type.\n *\n * @template TContext - The type of the context object that may be passed along with successful results\n *\n * @example\n * ```ts\n * const result = parallelTransactionPlanResult([\n *   singleResultA,\n *   singleResultB,\n * ]);\n * result satisfies ParallelTransactionPlanResult;\n * ```\n *\n * @see {@link parallelTransactionPlanResult}\n */\nexport type ParallelTransactionPlanResult<\n    TContext extends TransactionPlanResultContext = TransactionPlanResultContext,\n> = Readonly<{\n    kind: 'parallel';\n    plans: TransactionPlanResult<TContext>[];\n}>;\n\n/**\n * A result for a single transaction plan.\n *\n * This represents the execution result of a {@link SingleTransactionPlan} and\n * contains the original transaction message along with its execution status.\n *\n * You may use the {@link successfulSingleTransactionPlanResult},\n * {@link failedSingleTransactionPlanResult}, or {@link canceledSingleTransactionPlanResult}\n * helpers to create objects of this type.\n *\n * @template TContext - The type of the context object that may be passed along with successful results\n * @template TTransactionMessage - The type of the transaction message\n *\n * @example\n * Successful result with a transaction and context.\n * ```ts\n * const result = successfulSingleTransactionPlanResult(\n *   transactionMessage,\n *   transaction\n * );\n * result satisfies SingleTransactionPlanResult;\n * ```\n *\n * @example\n * Failed result with an error.\n * ```ts\n * const result = failedSingleTransactionPlanResult(\n *   transactionMessage,\n *   new SolanaError(SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE),\n * );\n * result satisfies SingleTransactionPlanResult;\n * ```\n *\n * @example\n * Canceled result.\n * ```ts\n * const result = canceledSingleTransactionPlanResult(transactionMessage);\n * result satisfies SingleTransactionPlanResult;\n * ```\n *\n * @see {@link successfulSingleTransactionPlanResult}\n * @see {@link failedSingleTransactionPlanResult}\n * @see {@link canceledSingleTransactionPlanResult}\n */\nexport type SingleTransactionPlanResult<\n    TContext extends TransactionPlanResultContext = TransactionPlanResultContext,\n    TTransactionMessage extends BaseTransactionMessage & TransactionMessageWithFeePayer = BaseTransactionMessage &\n        TransactionMessageWithFeePayer,\n> = Readonly<{\n    kind: 'single';\n    message: TTransactionMessage;\n    status: TransactionPlanResultStatus<TContext>;\n}>;\n\n/**\n * The status of a single transaction plan execution.\n *\n * This represents the outcome of executing a single transaction message and can be one of:\n * - `successful` - The transaction was successfully executed. Contains the transaction\n *   and an optional context object.\n * - `failed` - The transaction execution failed. Contains the error that caused the failure.\n * - `canceled` - The transaction execution was canceled.\n *\n * @template TContext - The type of the context object that may be passed along with successful results\n */\nexport type TransactionPlanResultStatus<TContext extends TransactionPlanResultContext = TransactionPlanResultContext> =\n    | Readonly<{ context: TContext; kind: 'successful'; transaction: Transaction }>\n    | Readonly<{ error: SolanaError; kind: 'failed' }>\n    | Readonly<{ kind: 'canceled' }>;\n\n/**\n * Creates a divisible {@link SequentialTransactionPlanResult} from an array of nested results.\n *\n * This function creates a sequential result with the `divisible` property set to `true`,\n * indicating that the nested plans were executed sequentially but could have been\n * split into separate transactions or batches.\n *\n * @template TContext - The type of the context object that may be passed along with successful results\n * @param plans - The child results that were executed sequentially\n *\n * @example\n * ```ts\n * const result = sequentialTransactionPlanResult([\n *   singleResultA,\n *   singleResultB,\n * ]);\n * result satisfies SequentialTransactionPlanResult & { divisible: true };\n * ```\n *\n * @see {@link SequentialTransactionPlanResult}\n */\nexport function sequentialTransactionPlanResult<\n    TContext extends TransactionPlanResultContext = TransactionPlanResultContext,\n>(plans: TransactionPlanResult<TContext>[]): SequentialTransactionPlanResult<TContext> & { divisible: true } {\n    return Object.freeze({ divisible: true, kind: 'sequential', plans });\n}\n\n/**\n * Creates a non-divisible {@link SequentialTransactionPlanResult} from an array of nested results.\n *\n * This function creates a sequential result with the `divisible` property set to `false`,\n * indicating that the nested plans were executed sequentially and could not have been\n * split into separate transactions or batches (e.g., they were executed as a transaction bundle).\n *\n * @template TContext - The type of the context object that may be passed along with successful results\n * @param plans - The child results that were executed sequentially\n *\n * @example\n * ```ts\n * const result = nonDivisibleSequentialTransactionPlanResult([\n *   singleResultA,\n *   singleResultB,\n * ]);\n * result satisfies SequentialTransactionPlanResult & { divisible: false };\n * ```\n *\n * @see {@link SequentialTransactionPlanResult}\n */\nexport function nonDivisibleSequentialTransactionPlanResult<\n    TContext extends TransactionPlanResultContext = TransactionPlanResultContext,\n>(plans: TransactionPlanResult<TContext>[]): SequentialTransactionPlanResult<TContext> & { divisible: false } {\n    return Object.freeze({ divisible: false, kind: 'sequential', plans });\n}\n\n/**\n * Creates a {@link ParallelTransactionPlanResult} from an array of nested results.\n *\n * This function creates a parallel result indicating that the nested plans\n * were executed in parallel.\n *\n * @template TContext - The type of the context object that may be passed along with successful results\n * @param plans - The child results that were executed in parallel\n *\n * @example\n * ```ts\n * const result = parallelTransactionPlanResult([\n *   singleResultA,\n *   singleResultB,\n * ]);\n * result satisfies ParallelTransactionPlanResult;\n * ```\n *\n * @see {@link ParallelTransactionPlanResult}\n */\nexport function parallelTransactionPlanResult<\n    TContext extends TransactionPlanResultContext = TransactionPlanResultContext,\n>(plans: TransactionPlanResult<TContext>[]): ParallelTransactionPlanResult<TContext> {\n    return Object.freeze({ kind: 'parallel', plans });\n}\n\n/**\n * Creates a successful {@link SingleTransactionPlanResult} from a transaction message and transaction.\n *\n * This function creates a single result with a 'successful' status, indicating that\n * the transaction was successfully executed. It also includes the original transaction\n * message, the executed transaction, and an optional context object.\n *\n * @template TContext - The type of the context object\n * @template TTransactionMessage - The type of the transaction message\n * @param transactionMessage - The original transaction message\n * @param transaction - The successfully executed transaction\n * @param context - Optional context object to be included with the result\n *\n * @example\n * ```ts\n * const result = successfulSingleTransactionPlanResult(\n *   transactionMessage,\n *   transaction\n * );\n * result satisfies SingleTransactionPlanResult;\n * ```\n *\n * @see {@link SingleTransactionPlanResult}\n */\nexport function successfulSingleTransactionPlanResult<\n    TContext extends TransactionPlanResultContext = TransactionPlanResultContext,\n    TTransactionMessage extends BaseTransactionMessage & TransactionMessageWithFeePayer = BaseTransactionMessage &\n        TransactionMessageWithFeePayer,\n>(\n    transactionMessage: TTransactionMessage,\n    transaction: Transaction,\n    context?: TContext,\n): SingleTransactionPlanResult<TContext, TTransactionMessage> {\n    return Object.freeze({\n        kind: 'single',\n        message: transactionMessage,\n        status: Object.freeze({ context: context ?? ({} as TContext), kind: 'successful', transaction }),\n    });\n}\n\n/**\n * Creates a failed {@link SingleTransactionPlanResult} from a transaction message and error.\n *\n * This function creates a single result with a 'failed' status, indicating that\n * the transaction execution failed. It includes the original transaction message\n * and the error that caused the failure.\n *\n * @template TContext - The type of the context object (not used in failed results)\n * @template TTransactionMessage - The type of the transaction message\n * @param transactionMessage - The original transaction message\n * @param error - The error that caused the transaction to fail\n *\n * @example\n * ```ts\n * const result = failedSingleTransactionPlanResult(\n *   transactionMessage,\n *   new SolanaError({\n *     code: 123,\n *     message: 'Transaction simulation failed',\n *   }),\n * );\n * result satisfies SingleTransactionPlanResult;\n * ```\n *\n * @see {@link SingleTransactionPlanResult}\n */\nexport function failedSingleTransactionPlanResult<\n    TContext extends TransactionPlanResultContext = TransactionPlanResultContext,\n    TTransactionMessage extends BaseTransactionMessage & TransactionMessageWithFeePayer = BaseTransactionMessage &\n        TransactionMessageWithFeePayer,\n>(\n    transactionMessage: TTransactionMessage,\n    error: SolanaError,\n): SingleTransactionPlanResult<TContext, TTransactionMessage> {\n    return Object.freeze({\n        kind: 'single',\n        message: transactionMessage,\n        status: Object.freeze({ error, kind: 'failed' }),\n    });\n}\n\n/**\n * Creates a canceled {@link SingleTransactionPlanResult} from a transaction message.\n *\n * This function creates a single result with a 'canceled' status, indicating that\n * the transaction execution was canceled. It includes the original transaction message.\n *\n * @template TContext - The type of the context object (not used in canceled results)\n * @template TTransactionMessage - The type of the transaction message\n * @param transactionMessage - The original transaction message\n *\n * @example\n * ```ts\n * const result = canceledSingleTransactionPlanResult(transactionMessage);\n * result satisfies SingleTransactionPlanResult;\n * ```\n *\n * @see {@link SingleTransactionPlanResult}\n */\nexport function canceledSingleTransactionPlanResult<\n    TContext extends TransactionPlanResultContext = TransactionPlanResultContext,\n    TTransactionMessage extends BaseTransactionMessage & TransactionMessageWithFeePayer = BaseTransactionMessage &\n        TransactionMessageWithFeePayer,\n>(transactionMessage: TTransactionMessage): SingleTransactionPlanResult<TContext, TTransactionMessage> {\n    return Object.freeze({\n        kind: 'single',\n        message: transactionMessage,\n        status: Object.freeze({ kind: 'canceled' }),\n    });\n}\n","import {\n    SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN,\n    SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND,\n    SolanaError,\n} from '@solana/errors';\nimport { getAbortablePromise } from '@solana/promises';\nimport { BaseTransactionMessage, TransactionMessageWithFeePayer } from '@solana/transaction-messages';\nimport { Transaction } from '@solana/transactions';\n\nimport type {\n    ParallelTransactionPlan,\n    SequentialTransactionPlan,\n    SingleTransactionPlan,\n    TransactionPlan,\n} from './transaction-plan';\nimport {\n    canceledSingleTransactionPlanResult,\n    failedSingleTransactionPlanResult,\n    nonDivisibleSequentialTransactionPlanResult,\n    parallelTransactionPlanResult,\n    sequentialTransactionPlanResult,\n    successfulSingleTransactionPlanResult,\n    type TransactionPlanResult,\n    type TransactionPlanResultContext,\n} from './transaction-plan-result';\n\nexport type TransactionPlanExecutor<TContext extends TransactionPlanResultContext = TransactionPlanResultContext> = (\n    transactionPlan: TransactionPlan,\n    config?: { abortSignal?: AbortSignal },\n) => Promise<TransactionPlanResult<TContext>>;\n\ntype ExecuteTransactionMessage = <TContext extends TransactionPlanResultContext = TransactionPlanResultContext>(\n    transactionMessage: BaseTransactionMessage & TransactionMessageWithFeePayer,\n    config?: { abortSignal?: AbortSignal },\n) => Promise<{ context?: TContext; transaction: Transaction }>;\n\n/**\n * Configuration object for creating a new transaction plan executor.\n *\n * @see {@link createTransactionPlanExecutor}\n */\nexport type TransactionPlanExecutorConfig = {\n    /** Called whenever a transaction message must be sent to the blockchain. */\n    executeTransactionMessage: ExecuteTransactionMessage;\n};\n\n/**\n * Creates a new transaction plan executor based on the provided configuration.\n *\n * The executor will traverse the provided `TransactionPlan` sequentially or in parallel,\n * executing each transaction message using the `executeTransactionMessage` function.\n *\n * - If that function is successful, the executor will return a successful `TransactionPlanResult`\n * for that message including the transaction and any custom context.\n * - If that function throws an error, the executor will stop processing and cancel all\n * remaining transaction messages in the plan.\n * - If the `abortSignal` is triggered, the executor will immediately stop processing the plan and\n * return a `TransactionPlanResult` with the status set to `canceled`.\n *\n * @example\n * ```ts\n * const sendAndConfirmTransaction = sendAndConfirmTransactionFactory({ rpc, rpcSubscriptions });\n *\n * const transactionPlanExecutor = createTransactionPlanExecutor({\n *   executeTransactionMessage: (message) => {\n *     const transaction = await signTransactionMessageWithSigners(message);\n *     await sendAndConfirmTransaction(transaction, { commitment: 'confirmed' });\n *     return { transaction };\n *   }\n * });\n * ```\n *\n * @see {@link TransactionPlannerConfig}\n */\nexport function createTransactionPlanExecutor(config: TransactionPlanExecutorConfig): TransactionPlanExecutor {\n    return async (plan, { abortSignal } = {}): Promise<TransactionPlanResult> => {\n        const context: TraverseContext = {\n            ...config,\n            abortSignal: abortSignal,\n            canceled: abortSignal?.aborted ?? false,\n        };\n\n        const cancelHandler = () => {\n            context.canceled = true;\n        };\n        abortSignal?.addEventListener('abort', cancelHandler);\n        const transactionPlanResult = await traverse(plan, context);\n        abortSignal?.removeEventListener('abort', cancelHandler);\n\n        if (context.canceled) {\n            const abortReason = abortSignal?.aborted ? abortSignal.reason : undefined;\n            const context = { cause: findErrorFromTransactionPlanResult(transactionPlanResult) ?? abortReason };\n            // Here we want the `transactionPlanResult` to be available in the error context\n            // so applications can create recovery plans but we don't want this object to be\n            // serialized with the error. This is why we set it as a non-enumerable property.\n            Object.defineProperty(context, 'transactionPlanResult', {\n                configurable: false,\n                enumerable: false,\n                value: transactionPlanResult,\n                writable: false,\n            });\n            throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN, context);\n        }\n\n        return transactionPlanResult;\n    };\n}\n\ntype TraverseContext = TransactionPlanExecutorConfig & {\n    abortSignal?: AbortSignal;\n    canceled: boolean;\n};\n\nasync function traverse(transactionPlan: TransactionPlan, context: TraverseContext): Promise<TransactionPlanResult> {\n    const kind = transactionPlan.kind;\n    switch (kind) {\n        case 'sequential':\n            return await traverseSequential(transactionPlan, context);\n        case 'parallel':\n            return await traverseParallel(transactionPlan, context);\n        case 'single':\n            return await traverseSingle(transactionPlan, context);\n        default:\n            transactionPlan satisfies never;\n            throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND, { kind });\n    }\n}\n\nasync function traverseSequential(\n    transactionPlan: SequentialTransactionPlan,\n    context: TraverseContext,\n): Promise<TransactionPlanResult> {\n    const results: TransactionPlanResult[] = [];\n\n    for (const subPlan of transactionPlan.plans) {\n        const result = await traverse(subPlan, context);\n        results.push(result);\n    }\n\n    return transactionPlan.divisible\n        ? sequentialTransactionPlanResult(results)\n        : nonDivisibleSequentialTransactionPlanResult(results);\n}\n\nasync function traverseParallel(\n    transactionPlan: ParallelTransactionPlan,\n    context: TraverseContext,\n): Promise<TransactionPlanResult> {\n    const results = await Promise.all(transactionPlan.plans.map(plan => traverse(plan, context)));\n    return parallelTransactionPlanResult(results);\n}\n\nasync function traverseSingle(\n    transactionPlan: SingleTransactionPlan,\n    context: TraverseContext,\n): Promise<TransactionPlanResult> {\n    if (context.canceled) {\n        return canceledSingleTransactionPlanResult(transactionPlan.message);\n    }\n\n    try {\n        const result = await getAbortablePromise(\n            context.executeTransactionMessage(transactionPlan.message, { abortSignal: context.abortSignal }),\n            context.abortSignal,\n        );\n        return successfulSingleTransactionPlanResult(transactionPlan.message, result.transaction, result.context);\n    } catch (error) {\n        context.canceled = true;\n        return failedSingleTransactionPlanResult(transactionPlan.message, error as SolanaError);\n    }\n}\n\nfunction findErrorFromTransactionPlanResult(result: TransactionPlanResult): SolanaError | undefined {\n    if (result.kind === 'single') {\n        return result.status.kind === 'failed' ? result.status.error : undefined;\n    }\n    for (const plan of result.plans) {\n        const error = findErrorFromTransactionPlanResult(plan);\n        if (error) {\n            return error;\n        }\n    }\n}\n","import { BaseTransactionMessage, TransactionMessageWithFeePayer } from '@solana/transaction-messages';\n\n/**\n * A set of transaction messages with constraints on how they can be executed.\n *\n * This is structured as a recursive tree of plans to allow for\n * parallel execution, sequential execution and combinations of both.\n *\n * Namely, the following plans are supported:\n * - {@link SingleTransactionPlan} - A plan that contains a single transaction message.\n *   This is the simplest leaf in this tree.\n * - {@link ParallelTransactionPlan} - A plan that contains other plans that\n *   can be executed in parallel.\n * - {@link SequentialTransactionPlan} - A plan that contains other plans that\n *   must be executed sequentially. It also defines whether the plan is divisible\n *   meaning that transaction messages inside it can be split into separate batches.\n *\n * Helpers are provided for each of these plans to make it easier to create them.\n *\n * @example\n * ```ts\n * const myTransactionPlan: TransactionPlan = parallelTransactionPlan([\n *   sequentialTransactionPlan([messageA, messageB]),\n *   messageC,\n * ]);\n * ```\n *\n * @see {@link SingleTransactionPlan}\n * @see {@link ParallelTransactionPlan}\n * @see {@link SequentialTransactionPlan}\n */\nexport type TransactionPlan = ParallelTransactionPlan | SequentialTransactionPlan | SingleTransactionPlan;\n\n/**\n * A plan wrapping other plans that must be executed sequentially.\n *\n * It also defines whether nested plans are divisible — meaning that\n * the transaction messages inside them can be split into separate batches.\n * When `divisible` is `false`, the transaction messages inside the plan should\n * all be executed atomically — usually in a transaction bundle.\n *\n * You may use the {@link sequentialTransactionPlan} and {@link nonDivisibleSequentialTransactionPlan}\n * helpers to create objects of this type.\n *\n * @example\n * Simple sequential plan with two transaction messages.\n * ```ts\n * const plan = sequentialTransactionPlan([messageA, messageB]);\n * plan satisfies SequentialTransactionPlan;\n * ```\n *\n * @example\n * Non-divisible sequential plan with two transaction messages.\n * ```ts\n * const plan = nonDivisibleSequentialTransactionPlan([messageA, messageB]);\n * plan satisfies SequentialTransactionPlan & { divisible: false };\n * ```\n *\n * @example\n * Sequential plan with nested parallel plans.\n * Here, messages A and B can be executed in parallel, but they must both be finalized\n * before messages C and D can be sent — which can also be executed in parallel.\n * ```ts\n * const plan = sequentialTransactionPlan([\n *   parallelTransactionPlan([messageA, messageB]),\n *   parallelTransactionPlan([messageC, messageD]),\n * ]);\n * ```\n *\n * @see {@link sequentialTransactionPlan}\n * @see {@link nonDivisibleSequentialTransactionPlan}\n */\nexport type SequentialTransactionPlan = Readonly<{\n    divisible: boolean;\n    kind: 'sequential';\n    plans: TransactionPlan[];\n}>;\n\n/**\n * A plan wrapping other plans that can be executed in parallel.\n *\n * This means direct children of this plan can be executed in separate\n * parallel transactions without causing any side effects.\n * However, the children themselves can define additional constraints\n * for that specific branch of the tree — such as the {@link SequentialTransactionPlan}.\n *\n * You may use the {@link parallelTransactionPlan} helper to create objects of this type.\n *\n * @example\n * Simple parallel plan with two transaction messages.\n * ```ts\n * const plan = parallelTransactionPlan([messageA, messageB]);\n * plan satisfies ParallelTransactionPlan;\n * ```\n *\n * @example\n * Parallel plan with nested sequential plans.\n * Here, messages A and B must be executed sequentially and so must messages C and D,\n * but both pairs can be executed in parallel.\n * ```ts\n * const plan = parallelTransactionPlan([\n *   sequentialTransactionPlan([messageA, messageB]),\n *   sequentialTransactionPlan([messageC, messageD]),\n * ]);\n * plan satisfies ParallelTransactionPlan;\n * ```\n *\n * @see {@link parallelTransactionPlan}\n */\nexport type ParallelTransactionPlan = Readonly<{\n    kind: 'parallel';\n    plans: TransactionPlan[];\n}>;\n\n/**\n * A plan that contains a single transaction message.\n *\n * This is a simple transaction message wrapper that transforms a message into a plan.\n *\n * You may use the {@link singleTransactionPlan} helper to create objects of this type.\n *\n * @example\n * ```ts\n * const plan = singleTransactionPlan(transactionMessage);\n * plan satisfies SingleTransactionPlan;\n * ```\n *\n * @see {@link singleTransactionPlan}\n */\nexport type SingleTransactionPlan<\n    TTransactionMessage extends BaseTransactionMessage & TransactionMessageWithFeePayer = BaseTransactionMessage &\n        TransactionMessageWithFeePayer,\n> = Readonly<{\n    kind: 'single';\n    message: TTransactionMessage;\n}>;\n\n/**\n * Creates a {@link ParallelTransactionPlan} from an array of nested plans.\n *\n * It can accept {@link TransactionMessage} objects directly, which will be wrapped\n * in {@link SingleTransactionPlan | SingleTransactionPlans} automatically.\n *\n * @example\n * Using explicit {@link SingleTransactionPlan | SingleTransactionPlans}.\n * ```ts\n * const plan = parallelTransactionPlan([\n *   singleTransactionPlan(messageA),\n *   singleTransactionPlan(messageB),\n * ]);\n * ```\n *\n * @example\n * Using {@link TransactionMessage | TransactionMessages} directly.\n * ```ts\n * const plan = parallelTransactionPlan([messageA, messageB]);\n * ```\n *\n * @see {@link ParallelTransactionPlan}\n */\nexport function parallelTransactionPlan(\n    plans: (TransactionPlan | (BaseTransactionMessage & TransactionMessageWithFeePayer))[],\n): ParallelTransactionPlan {\n    return Object.freeze({ kind: 'parallel', plans: parseSingleTransactionPlans(plans) });\n}\n\n/**\n * Creates a divisible {@link SequentialTransactionPlan} from an array of nested plans.\n *\n * It can accept {@link TransactionMessage} objects directly, which will be wrapped\n * in {@link SingleTransactionPlan | SingleTransactionPlans} automatically.\n *\n * @example\n * Using explicit {@link SingleTransactionPlan | SingleTransactionPlans}.\n * ```ts\n * const plan = sequentialTransactionPlan([\n *   singleTransactionPlan(messageA),\n *   singleTransactionPlan(messageB),\n * ]);\n * ```\n *\n * @example\n * Using {@link TransactionMessage | TransactionMessages} directly.\n * ```ts\n * const plan = sequentialTransactionPlan([messageA, messageB]);\n * ```\n *\n * @see {@link SequentialTransactionPlan}\n */\nexport function sequentialTransactionPlan(\n    plans: (TransactionPlan | (BaseTransactionMessage & TransactionMessageWithFeePayer))[],\n): SequentialTransactionPlan & { divisible: true } {\n    return Object.freeze({ divisible: true, kind: 'sequential', plans: parseSingleTransactionPlans(plans) });\n}\n\n/**\n * Creates a non-divisible {@link SequentialTransactionPlan} from an array of nested plans.\n *\n * It can accept {@link TransactionMessage} objects directly, which will be wrapped\n * in {@link SingleTransactionPlan | SingleTransactionPlans} automatically.\n *\n * @example\n * Using explicit {@link SingleTransactionPlan | SingleTransactionPlans}.\n * ```ts\n * const plan = nonDivisibleSequentialTransactionPlan([\n *   singleTransactionPlan(messageA),\n *   singleTransactionPlan(messageB),\n * ]);\n * ```\n *\n * @example\n * Using {@link TransactionMessage | TransactionMessages} directly.\n * ```ts\n * const plan = nonDivisibleSequentialTransactionPlan([messageA, messageB]);\n * ```\n *\n * @see {@link SequentialTransactionPlan}\n */\nexport function nonDivisibleSequentialTransactionPlan(\n    plans: (TransactionPlan | (BaseTransactionMessage & TransactionMessageWithFeePayer))[],\n): SequentialTransactionPlan & { divisible: false } {\n    return Object.freeze({ divisible: false, kind: 'sequential', plans: parseSingleTransactionPlans(plans) });\n}\n\n/**\n * Creates a {@link SingleTransactionPlan} from a {@link TransactionMessage} object.\n *\n * @example\n * ```ts\n * const plan = singleTransactionPlan(transactionMessage);\n * plan satisfies SingleTransactionPlan;\n * ```\n *\n * @see {@link SingleTransactionPlan}\n */\nexport function singleTransactionPlan<\n    TTransactionMessage extends BaseTransactionMessage & TransactionMessageWithFeePayer = BaseTransactionMessage &\n        TransactionMessageWithFeePayer,\n>(transactionMessage: TTransactionMessage): SingleTransactionPlan<TTransactionMessage> {\n    return Object.freeze({ kind: 'single', message: transactionMessage });\n}\n\nfunction parseSingleTransactionPlans(\n    plans: (TransactionPlan | (BaseTransactionMessage & TransactionMessageWithFeePayer))[],\n): TransactionPlan[] {\n    return plans.map(plan => ('kind' in plan ? plan : singleTransactionPlan(plan)));\n}\n\n/**\n * Retrieves all individual {@link SingleTransactionPlan} instances from a transaction plan tree.\n *\n * This function recursively traverses any nested structure of transaction plans and extracts\n * all the single transaction plans they contain. It's useful when you need to access all\n * the actual transaction messages that will be executed, regardless of their organization\n * in the plan tree (parallel or sequential).\n *\n * @param transactionPlan - The transaction plan to extract single plans from\n * @returns An array of all single transaction plans contained in the tree\n *\n * @example\n * ```ts\n * const plan = parallelTransactionPlan([\n *   sequentialTransactionPlan([messageA, messageB]),\n *   nonDivisibleSequentialTransactionPlan([messageC, messageD]),\n *   messageE,\n * ]);\n *\n * const singlePlans = getAllSingleTransactionPlans(plan);\n * // Array of `SingleTransactionPlan` containing:\n * // messageA, messageB, messageC and messageD.\n * ```\n */\nexport function getAllSingleTransactionPlans(transactionPlan: TransactionPlan): SingleTransactionPlan[] {\n    if (transactionPlan.kind === 'single') {\n        return [transactionPlan];\n    }\n    return transactionPlan.plans.flatMap(getAllSingleTransactionPlans);\n}\n","import {\n    isSolanaError,\n    SOLANA_ERROR__INSTRUCTION_PLANS__EMPTY_INSTRUCTION_PLAN,\n    SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN,\n    SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND,\n    SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND,\n    SolanaError,\n} from '@solana/errors';\nimport { getAbortablePromise } from '@solana/promises';\nimport {\n    appendTransactionMessageInstructions,\n    BaseTransactionMessage,\n    TransactionMessageWithFeePayer,\n} from '@solana/transaction-messages';\nimport { getTransactionMessageSize, TRANSACTION_SIZE_LIMIT } from '@solana/transactions';\n\nimport {\n    InstructionPlan,\n    MessagePackerInstructionPlan,\n    ParallelInstructionPlan,\n    SequentialInstructionPlan,\n    SingleInstructionPlan,\n} from './instruction-plan';\nimport {\n    getAllSingleTransactionPlans,\n    nonDivisibleSequentialTransactionPlan,\n    parallelTransactionPlan,\n    sequentialTransactionPlan,\n    SingleTransactionPlan,\n    singleTransactionPlan,\n    TransactionPlan,\n} from './transaction-plan';\n\n/**\n * Plans one or more transactions according to the provided instruction plan.\n *\n * @param instructionPlan - The instruction plan to be planned and executed.\n * @param config - Optional configuration object that can include an `AbortSignal` to cancel the planning process.\n *\n * @see {@link InstructionPlan}\n * @see {@link TransactionPlan}\n */\nexport type TransactionPlanner = (\n    instructionPlan: InstructionPlan,\n    config?: { abortSignal?: AbortSignal },\n) => Promise<TransactionPlan>;\n\ntype Mutable<T> = { -readonly [P in keyof T]: T[P] };\n\ntype CreateTransactionMessage = (config?: {\n    abortSignal?: AbortSignal;\n}) =>\n    | Promise<BaseTransactionMessage & TransactionMessageWithFeePayer>\n    | (BaseTransactionMessage & TransactionMessageWithFeePayer);\n\ntype OnTransactionMessageUpdated = (\n    transactionMessage: BaseTransactionMessage & TransactionMessageWithFeePayer,\n    config?: { abortSignal?: AbortSignal },\n) =>\n    | Promise<BaseTransactionMessage & TransactionMessageWithFeePayer>\n    | (BaseTransactionMessage & TransactionMessageWithFeePayer);\n\n/**\n * Configuration object for creating a new transaction planner.\n *\n * @see {@link createTransactionPlanner}\n */\nexport type TransactionPlannerConfig = {\n    /** Called whenever a new transaction message is needed. */\n    createTransactionMessage: CreateTransactionMessage;\n    /**\n     * Called whenever a transaction message is updated — e.g. new instructions were added.\n     * This function must return the updated transaction message back — even if no changes were made.\n     */\n    onTransactionMessageUpdated?: OnTransactionMessageUpdated;\n};\n\n/**\n * Creates a new transaction planner based on the provided configuration.\n *\n * At the very least, the `createTransactionMessage` function must be provided.\n * This function is used to create new transaction messages whenever needed.\n *\n * Additionally, the `onTransactionMessageUpdated` function can be provided\n * to update transaction messages during the planning process. This function will\n * be called whenever a transaction message is updated, e.g. when new instructions\n * are added to a transaction message. It accepts the updated transaction message\n * and must return a transaction message back, even if no changes were made.\n *\n * @example\n * ```ts\n * const transactionPlanner = createTransactionPlanner({\n *   createTransactionMessage: () => pipe(\n *     createTransactionMessage({ version: 0 }),\n *     message => setTransactionMessageFeePayerSigner(mySigner, message),\n *   )\n * });\n * ```\n *\n * @see {@link TransactionPlannerConfig}\n */\nexport function createTransactionPlanner(config: TransactionPlannerConfig): TransactionPlanner {\n    return async (instructionPlan, { abortSignal } = {}): Promise<TransactionPlan> => {\n        const plan = await traverse(instructionPlan, {\n            abortSignal,\n            createTransactionMessage: config.createTransactionMessage,\n            onTransactionMessageUpdated: config.onTransactionMessageUpdated ?? (msg => msg),\n            parent: null,\n            parentCandidates: [],\n        });\n\n        if (!plan) {\n            throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__EMPTY_INSTRUCTION_PLAN);\n        }\n\n        return freezeTransactionPlan(plan);\n    };\n}\n\ntype MutableTransactionPlan = Mutable<TransactionPlan>;\ntype MutableSingleTransactionPlan = Mutable<SingleTransactionPlan>;\n\ntype TraverseContext = {\n    abortSignal?: AbortSignal;\n    createTransactionMessage: CreateTransactionMessage;\n    onTransactionMessageUpdated: OnTransactionMessageUpdated;\n    parent: InstructionPlan | null;\n    parentCandidates: MutableSingleTransactionPlan[];\n};\n\nasync function traverse(\n    instructionPlan: InstructionPlan,\n    context: TraverseContext,\n): Promise<MutableTransactionPlan | null> {\n    context.abortSignal?.throwIfAborted();\n    const kind = instructionPlan.kind;\n    switch (kind) {\n        case 'sequential':\n            return await traverseSequential(instructionPlan, context);\n        case 'parallel':\n            return await traverseParallel(instructionPlan, context);\n        case 'single':\n            return await traverseSingle(instructionPlan, context);\n        case 'messagePacker':\n            return await traverseMessagePacker(instructionPlan, context);\n        default:\n            instructionPlan satisfies never;\n            throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND, { kind });\n    }\n}\n\nasync function traverseSequential(\n    instructionPlan: SequentialInstructionPlan,\n    context: TraverseContext,\n): Promise<MutableTransactionPlan | null> {\n    let candidate: MutableSingleTransactionPlan | null = null;\n\n    // Check if the sequential plan must fit entirely in its parent candidates\n    // due to constraints like being inside a parallel plan or not being divisible.\n    const mustEntirelyFitInParentCandidate =\n        context.parent && (context.parent.kind === 'parallel' || !instructionPlan.divisible);\n\n    // If so, try to fit the entire plan inside one of the parent candidates.\n    if (mustEntirelyFitInParentCandidate) {\n        const candidate = await selectAndMutateCandidate(context, context.parentCandidates, message =>\n            fitEntirePlanInsideMessage(instructionPlan, message),\n        );\n        // If that's possible, we the candidate is mutated and we can return null.\n        // Otherwise, we proceed with the normal traversal and no parent candidate.\n        if (candidate) {\n            return null;\n        }\n    } else {\n        // Otherwise, we can use the first parent candidate, if any,\n        // since we know it must be a divisible sequential plan.\n        candidate = context.parentCandidates.length > 0 ? context.parentCandidates[0] : null;\n    }\n\n    const transactionPlans: TransactionPlan[] = [];\n    for (const plan of instructionPlan.plans) {\n        const transactionPlan = await traverse(plan, {\n            ...context,\n            parent: instructionPlan,\n            parentCandidates: candidate ? [candidate] : [],\n        });\n        if (transactionPlan) {\n            candidate = getSequentialCandidate(transactionPlan);\n            const newPlans =\n                transactionPlan.kind === 'sequential' && (transactionPlan.divisible || !instructionPlan.divisible)\n                    ? transactionPlan.plans\n                    : [transactionPlan];\n            transactionPlans.push(...newPlans);\n        }\n    }\n\n    // Wrap in a sequential plan or simplify.\n    if (transactionPlans.length === 1) {\n        return transactionPlans[0];\n    }\n    if (transactionPlans.length === 0) {\n        return null;\n    }\n    return {\n        divisible: instructionPlan.divisible,\n        kind: 'sequential',\n        plans: transactionPlans,\n    };\n}\n\nasync function traverseParallel(\n    instructionPlan: ParallelInstructionPlan,\n    context: TraverseContext,\n): Promise<MutableTransactionPlan | null> {\n    const candidates: MutableSingleTransactionPlan[] = [...context.parentCandidates];\n    const transactionPlans: TransactionPlan[] = [];\n\n    // Reorder children so message packer plans are last.\n    const sortedChildren = Array.from(instructionPlan.plans).sort(\n        (a, b) => Number(a.kind === 'messagePacker') - Number(b.kind === 'messagePacker'),\n    );\n\n    for (const plan of sortedChildren) {\n        const transactionPlan = await traverse(plan, {\n            ...context,\n            parent: instructionPlan,\n            parentCandidates: candidates,\n        });\n        if (transactionPlan) {\n            candidates.push(...getParallelCandidates(transactionPlan));\n            const newPlans = transactionPlan.kind === 'parallel' ? transactionPlan.plans : [transactionPlan];\n            transactionPlans.push(...newPlans);\n        }\n    }\n\n    // Wrap in a parallel plan or simplify.\n    if (transactionPlans.length === 1) {\n        return transactionPlans[0];\n    }\n    if (transactionPlans.length === 0) {\n        return null;\n    }\n    return { kind: 'parallel', plans: transactionPlans };\n}\n\nasync function traverseSingle(\n    instructionPlan: SingleInstructionPlan,\n    context: TraverseContext,\n): Promise<MutableTransactionPlan | null> {\n    const predicate = (message: BaseTransactionMessage & TransactionMessageWithFeePayer) =>\n        appendTransactionMessageInstructions([instructionPlan.instruction], message);\n    const candidate = await selectAndMutateCandidate(context, context.parentCandidates, predicate);\n    if (candidate) {\n        return null;\n    }\n    const message = await createNewMessage(context, predicate);\n    return { kind: 'single', message };\n}\n\nasync function traverseMessagePacker(\n    instructionPlan: MessagePackerInstructionPlan,\n    context: TraverseContext,\n): Promise<MutableTransactionPlan | null> {\n    const messagePacker = instructionPlan.getMessagePacker();\n    const transactionPlans: SingleTransactionPlan[] = [];\n    const candidates = [...context.parentCandidates];\n\n    while (!messagePacker.done()) {\n        const candidate = await selectAndMutateCandidate(context, candidates, messagePacker.packMessageToCapacity);\n        if (!candidate) {\n            const message = await createNewMessage(context, messagePacker.packMessageToCapacity);\n            const newPlan: MutableSingleTransactionPlan = { kind: 'single', message };\n            transactionPlans.push(newPlan);\n        }\n    }\n\n    if (transactionPlans.length === 1) {\n        return transactionPlans[0];\n    }\n    if (transactionPlans.length === 0) {\n        return null;\n    }\n    if (context.parent?.kind === 'parallel') {\n        return { kind: 'parallel', plans: transactionPlans };\n    }\n    return {\n        divisible: context.parent?.kind === 'sequential' ? context.parent.divisible : true,\n        kind: 'sequential',\n        plans: transactionPlans,\n    };\n}\n\nfunction getSequentialCandidate(latestPlan: MutableTransactionPlan): MutableSingleTransactionPlan | null {\n    if (latestPlan.kind === 'single') {\n        return latestPlan;\n    }\n    if (latestPlan.kind === 'sequential' && latestPlan.plans.length > 0) {\n        return getSequentialCandidate(latestPlan.plans[latestPlan.plans.length - 1]);\n    }\n    return null;\n}\n\nfunction getParallelCandidates(latestPlan: TransactionPlan): MutableSingleTransactionPlan[] {\n    return getAllSingleTransactionPlans(latestPlan);\n}\n\nasync function selectAndMutateCandidate(\n    context: Pick<TraverseContext, 'abortSignal' | 'onTransactionMessageUpdated'>,\n    candidates: MutableSingleTransactionPlan[],\n    predicate: (\n        message: BaseTransactionMessage & TransactionMessageWithFeePayer,\n    ) => BaseTransactionMessage & TransactionMessageWithFeePayer,\n): Promise<MutableSingleTransactionPlan | null> {\n    for (const candidate of candidates) {\n        try {\n            const message = await getAbortablePromise(\n                Promise.resolve(\n                    context.onTransactionMessageUpdated(predicate(candidate.message), {\n                        abortSignal: context.abortSignal,\n                    }),\n                ),\n                context.abortSignal,\n            );\n            if (getTransactionMessageSize(message) <= TRANSACTION_SIZE_LIMIT) {\n                candidate.message = message;\n                return candidate;\n            }\n        } catch (error) {\n            if (isSolanaError(error, SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN)) {\n                // Try the next candidate.\n            } else {\n                throw error;\n            }\n        }\n    }\n    return null;\n}\n\nasync function createNewMessage(\n    context: Pick<TraverseContext, 'abortSignal' | 'createTransactionMessage' | 'onTransactionMessageUpdated'>,\n    predicate: (\n        message: BaseTransactionMessage & TransactionMessageWithFeePayer,\n    ) => BaseTransactionMessage & TransactionMessageWithFeePayer,\n): Promise<BaseTransactionMessage & TransactionMessageWithFeePayer> {\n    const newMessage = await getAbortablePromise(\n        Promise.resolve(context.createTransactionMessage({ abortSignal: context.abortSignal })),\n        context.abortSignal,\n    );\n    const updatedMessage = await getAbortablePromise(\n        Promise.resolve(\n            context.onTransactionMessageUpdated(predicate(newMessage), { abortSignal: context.abortSignal }),\n        ),\n        context.abortSignal,\n    );\n    const updatedMessageSize = getTransactionMessageSize(updatedMessage);\n    if (updatedMessageSize > TRANSACTION_SIZE_LIMIT) {\n        const newMessageSize = getTransactionMessageSize(newMessage);\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN, {\n            numBytesRequired: updatedMessageSize - newMessageSize,\n            numFreeBytes: TRANSACTION_SIZE_LIMIT - newMessageSize,\n        });\n    }\n    return updatedMessage;\n}\n\nfunction freezeTransactionPlan(plan: MutableTransactionPlan): TransactionPlan {\n    const kind = plan.kind;\n    switch (kind) {\n        case 'single':\n            return singleTransactionPlan(plan.message);\n        case 'sequential':\n            return plan.divisible\n                ? sequentialTransactionPlan(plan.plans.map(freezeTransactionPlan))\n                : nonDivisibleSequentialTransactionPlan(plan.plans.map(freezeTransactionPlan));\n        case 'parallel':\n            return parallelTransactionPlan(plan.plans.map(freezeTransactionPlan));\n        default:\n            plan satisfies never;\n            throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND, { kind });\n    }\n}\n\nfunction fitEntirePlanInsideMessage(\n    instructionPlan: InstructionPlan,\n    message: BaseTransactionMessage & TransactionMessageWithFeePayer,\n): BaseTransactionMessage & TransactionMessageWithFeePayer {\n    let newMessage: BaseTransactionMessage & TransactionMessageWithFeePayer = message;\n\n    const kind = instructionPlan.kind;\n    switch (kind) {\n        case 'sequential':\n        case 'parallel':\n            for (const plan of instructionPlan.plans) {\n                newMessage = fitEntirePlanInsideMessage(plan, newMessage);\n            }\n            return newMessage;\n        case 'single':\n            newMessage = appendTransactionMessageInstructions([instructionPlan.instruction], message);\n            // eslint-disable-next-line no-case-declarations\n            const newMessageSize = getTransactionMessageSize(newMessage);\n            if (newMessageSize > TRANSACTION_SIZE_LIMIT) {\n                const baseMessageSize = getTransactionMessageSize(message);\n                throw new SolanaError(SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN, {\n                    numBytesRequired: newMessageSize - baseMessageSize,\n                    numFreeBytes: TRANSACTION_SIZE_LIMIT - baseMessageSize,\n                });\n            }\n            return newMessage;\n        case 'messagePacker':\n            // eslint-disable-next-line no-case-declarations\n            const messagePacker = instructionPlan.getMessagePacker();\n            while (!messagePacker.done()) {\n                newMessage = messagePacker.packMessageToCapacity(message);\n            }\n            return newMessage;\n        default:\n            instructionPlan satisfies never;\n            throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND, { kind });\n    }\n}\n"]}